import numpy as np
from scipy.optimize import minimize

from envs.config_para_user_Nd_50 import (
    T_slot, Nd, ua, ub, uc, dl_i_t, ul_i_t, 
    
)

###########################################
# Environment ï¼š User_SFB_Model
# Points: _user_response_single_stepï¼ˆï¼‰
print("User_SFB_Model in Version-251219ï¼šAdding Opt_di-uncertainty")
##########################################
   
# ğŸ’¡user model with dynamic price sensitivity & satisfactionion back:
class User_SFB_Model():
    """
    Initialize the class of Users:
    user model with dynamic price sensitivity & satisfactionion back
    
    Functions:
    -----------
    obj_funcs:  Sum up the T_length cost objective of user i under give action lambda_p
    user_response: Get the T_length optimal user consumption & satisfaction level under give action lambda_p

    -----------
    """
    def __init__(self,
                is_step_complaint = True,
                is_ps_dynamic = False,
                user_sigma:float = 0.05) -> None:    
        
        self.user_sigma = user_sigma
        self.Nd = Nd
        self.ua = ua
        self.ub = ub
        self.uc = uc
        self.dl_i_t = dl_i_t
        self.ul_i_t = ul_i_t
        
        self.is_ps_dynamic = is_ps_dynamic
        self.is_step_complaint = is_step_complaint

        # reset æ‰éœ€è¦èµ‹å€¼
        self.ps_i  = None
        self.last_sat_i = None
        self.dit_last = None
        
        # å½“å‰è®¾ç½®ä¸‹ï¼Œä¸ä¼šç ´å ramp rate çº¦æŸ 
        self.delta_di = (ul_i_t - dl_i_t) * 2
        
        self.max_deviation = ul_i_t - dl_i_t
        self.d_ideal_i_t = 0.9*ul_i_t
        self.T_slot = T_slot

        # é¦–æ¬¡åˆå§‹åŒ–æ»¡æ„åº¦æƒé‡/åç»­åˆ™ä¸éœ€è¦æ›´æ–°
        self._gen_sat_characteristics()
        
   

    def cal_satisfaction(self, dt, dt_last, indices):
        """
            Get user satisfaction level under current power demand decision
            
            :param 
                dt : R^Nd optimal demand generated by economic decision model
                dt_last: R^Nd : demand in the last one period 
                indices : array of indices for Nd users in the specific time slot 
            :return : satisfaction evaluation value (array of shape (Nd,), values in [0, 10])
        """
       
        # æ•°å€¼ç¨³å®šæ€§ï¼šé¿å…é™¤é›¶ï¼Œä½¿ç”¨å°å¸¸æ•° epsilon
        eps = 1e-8
        
        # ç”¨ç”µæ»¡è¶³ç¨‹åº¦ c1
        d_ideal_safe = self.d_ideal_i_t[indices] + eps
        c1 = np.minimum(1.0, dt / d_ideal_safe)
        
        # å˜åŒ–ç¨‹åº¦ (0, 1)
        max_dev_safe = self.max_deviation[indices] + eps
        c2 = 1.0 - np.abs(dt - dt_last) / max_dev_safe
        c2 = np.clip(c2, 0.0, 1.0)  # ç¡®ä¿åœ¨ [0, 1] èŒƒå›´å†…

        # è¾¹ç•Œæ»¡æ„åº¦ï¼šæ¥è¿‘ä¸‹è¾¹ç•Œæ—¶é™ä¸º0
        boundary_threshold = 0.05 * self.max_deviation[indices]
        # c3 = np.where(np.logical_or(
        #     (self.ul_i_t[indices] - dt) <= boundary_threshold,
        #     (dt - self.dl_i_t[indices]) <= boundary_threshold), 0, 1)
        
        c3 = np.where((dt - self.dl_i_t[indices]) <= boundary_threshold, 0, 1)
        
        sat = np.sum(self.satisfaction_weights * (np.array([c1,c2,c3]).T),axis = 1)
        sat = np.clip(sat, 0.0, 1.0)
        
        
        
        return np.round(sat, 1)
    
    def user_response(self, lambda_p, hour_index=None):
        """
        Get optimal user consumption under given action lambda_p.
        
        Current implementation: Processes single time step (t=hour_index).
        Future extension: Can process multi-time step optimization (T_length > 1).
        
        :param lambda_p : electricity price(s) given by the upper agent(action)
                          - Current: [price_t] for single time step
                          - Future: [price_0, price_1, ..., price_T-1] for T time steps
                          Can be list, array, or scalar
        :param hour_index : index hour t in [0, T_slot-1] for single-step mode
                          If None and len(lambda_p) > 1, will trigger multi-step optimization
        :return : Opt_demand (array of shape (Nd,)), satisfaction_level (array of shape (Nd,))
                  - Current: single time step results
                  - Future: (T_length, Nd) arrays for multi-step results
        """
        lambda_p = np.asarray(lambda_p)
        T_length = len(lambda_p) if lambda_p.ndim > 0 else 1
        
       
        # å½“å‰å®ç°ï¼šå•æ—¶åˆ»æ¨¡å¼ (T_length = 1)
        if T_length == 1:
            return self._user_response_single_step(lambda_p[0], hour_index)
        # æœªæ¥æ‰©å±•ï¼šå¤šæ—¶åˆ»ä¼˜åŒ–æ¨¡å¼ (T_length > 1)
        else:
            # TODO: Implement multi-step optimization
            # This will involve solving an optimization problem across all T_length time steps
            # considering ramp rate constraints, satisfaction dynamics, and price sensitivity updates
            raise NotImplementedError(
                f"Multi-step optimization (T_length={T_length}) is not yet implemented. "
                "This feature will solve the optimization problem for all time steps simultaneously."
            )
    
    def _user_response_single_step(self, lambda_p_value: float, hour_index):
        """
        Single time step user response computation.
        Internal helper method for the single-step case.
        
        :param lambda_p_value: electricity price for the current time step
        :param hour_index: index hour t in [0, T_slot-1]
        :return: Opt_demand (Nd,), satisfaction_level (Nd,)
        """
        
        # è®¡ç®—å½“å‰æ—¶é—´æ®µçš„ç”¨æˆ·ç´¢å¼•
        indices = np.arange(self.Nd) * self.T_slot + hour_index
        
        # dit_last è¿˜è¢«ç”¨äº cal_user_satisfactionï¼Œå› æ­¤ï¼Œæ­¤å¤„æœ€å¥½ä½¿ç”¨å‰¯æœ¬
        dit_last = self.dit_last.copy()  # pyright: ignore[reportOptionalMemberAccess]
        
        # è®¡ç®—ramp rateçº¦æŸè¾¹ç•Œï¼ˆè€ƒè™‘ä¸Šä¸‹é™å’Œramp rateé™åˆ¶ï¼‰
        lower_bounds = np.maximum(
            self.dl_i_t[indices], 
            dit_last - self.delta_di[indices]
        )
        upper_bounds = np.minimum(
            self.ul_i_t[indices], 
            dit_last + self.delta_di[indices]
        )
        
        # Compute optimal demand for all users at once
        # ç†è®ºæœ€ä¼˜è§£ï¼šåŸºäºä¸€é˜¶æœ€ä¼˜æ€§æ¡ä»¶
        opt_di = (self.ps_i * lambda_p_value / (2 * ua) - self.ub / (2 * ua))  # pyright: ignore[reportOptionalOperand]
        opt_di = np.clip(opt_di, lower_bounds, upper_bounds)
        
        noise_di = self.user_rng.normal(loc=1.0,scale=self.user_sigma,size = opt_di.shape)
        # print(noise_di[0])
        opt_di = opt_di * noise_di
        opt_di = np.clip(opt_di, lower_bounds, upper_bounds)
        # è®¡ç®—æ»¡æ„åº¦
        sat_level = self.cal_satisfaction(opt_di, dit_last, indices)
        
        # NOTE - Update user model states (å¿…é¡»åœ¨è¿”å›å‰æ›´æ–°ï¼Œä¿è¯çŠ¶æ€ä¸€è‡´æ€§)
        self._sensitivy_updates(sat_level)
        self.dit_last = opt_di  
        self.last_sat_i = sat_level 
        
        if self.is_step_complaint:
            complaint_list  = np.where(sat_level>self.satisfaction_tolerance,0,1)
            comp_number = np.sum(complaint_list)
        else:
            comp_number = 0
        
        return opt_di, sat_level,comp_number
    
    def _random_init_user_model(self,user_rng,current_hour_index):
        # éšæœºåˆå§‹åŒ–ç”¨æˆ·æ¨¡å‹
        indices = np.arange(self.Nd)*self.T_slot + (current_hour_index%24) # è¡¥å…… self.indices
        ul_t,dl_t = self.ul_i_t[indices],self.dl_i_t[indices]

        self.dit_last  = user_rng.uniform(dl_t,ul_t)  # pyright: ignore[reportOptionalMemberAccess]
        self.last_sat_i = np.round(0.6*np.ones(self.Nd) + user_rng.uniform(0,0.1,self.Nd),1)  # pyright: ignore[reportOptionalMemberAccess]

        if self.is_ps_dynamic:
            price_senstivity = np.ones(self.Nd) + user_rng.uniform(0,0.1,self.Nd)   # pyright: ignore[reportOptionalMemberAccess]
        else:
            price_senstivity = np.ones(self.Nd)
        
        self.ps_i = price_senstivity.copy()  # self.ps_i åç»­å¯èƒ½ä¼šè¢«æ›´æ–°

        self.user_rng = user_rng
        
 
    def _gen_sat_characteristics(self):
        """ç”Ÿæˆæ¯ä¸ªç”¨æˆ·çš„æ»¡æ„åº¦æƒé‡ï¼Œç¡®ä¿w1+w2+w3=1"""
        
        param_rng = np.random.default_rng(40)
        
        raw_weights = param_rng.uniform(0.15, 0.65, (self.Nd, 3))
        
        # å½’ä¸€åŒ–ä½¿æ¯è¡Œå’Œä¸º1
        self.satisfaction_weights = raw_weights / raw_weights.sum(axis=1, keepdims=True)
       
        # æš‚å®šç»Ÿä¸€çš„å®¹å¿åº¦ 
        self.satisfaction_tolerance = 0.4
        # param_rng.uniform(0.4, 0.6, (self.Nd, ))
        
    
    def _sensitivy_updates(self, now_sat_i):
        '''
        update user's price sensitivity if is_ps_dynamic is True
        
        :param now_sat_i: current satisfaction level (array of shape (Nd,))
        :return: None
        '''

        if self.is_ps_dynamic:
            sat_change_rate = 0.5 * (now_sat_i - self.last_sat_i)
            # æ»¡æ„åº¦å‡é«˜ï¼Œsat_change_rate>0,ç»æµæˆæœ¬æƒé‡é™ä½,ç”¨æˆ·å‚ä¸DRæ„æ„¿å¢å¼º
            # æ»¡æ„åº¦é™ä½ï¼Œsat_change_rate<0,ç»æµæˆæœ¬æƒé‡å‡é«˜,ç”¨æˆ·å‚ä¸DRæ„æ„¿å‡å¼±
            self.ps_i = (1 + sat_change_rate) * self.ps_i
            self.ps_i = np.clip(self.ps_i, 0.5, 2.0)
         

if __name__ == "__main__":
    
    User = User_SFB_Model(is_ps_dynamic=False,is_step_complaint=True)
    user_rng = np.random.default_rng(seed=42)
       
    # Example placeholders for dit_last and t, replace with actual values as needed
    hour_index = 0
    User._random_init_user_model(user_rng,hour_index) 
    for hour_index in range(24):
        indices =np.arange(Nd)*T_slot + hour_index
        # dit_last =np.asarray(0.55*User.ul_i_t[indices])
        # æ‰‹åŠ¨reset -inner user

        di,sat_i,comp_number = User.user_response([10.0], hour_index)
        # print("hour_index",hour_index,"\n","Optimal demand:","\n", di, "Satisfaction:","\n", sat_i,"complaint number:",comp_number)
        

    # lp_list = np.arange(1.0,25.0,1.0)
    # import matplotlib.pyplot as plt
    
    # dt = np.zeros((len(lp_list),))
    # r = np.zeros((len(lp_list),))
    # for hour_index in range(24):
    #     for lp in lp_list:
    #         dit,sit = User.user_response([lp], hour_index)
    #         # print("satisfaction",sit)
    #         # print("price-s",User.ps_i)
    #         dt[int(lp-1)] = np.sum(dit)
    #         r[int(lp-1)] = np.sum(dit)*lp
        
    #     fig, ax1 = plt.subplots()
    #     color1 = 'k'
    #     ax1.set_xlabel('lambda_p')
    #     ax1.set_ylabel('Total demand (dt)', color=color1)
    #     ax1.plot(lp_list, dt, color1+'-o', label='Total demand')
    #     ax1.tick_params(axis='y', labelcolor=color1)

    #     ax2 = ax1.twinx()
    #     color2 = 'g'
    #     ax2.set_ylabel('Revenue (r)', color=color2)
    #     ax2.plot(lp_list, r, color2+'-o', label='Revenue')
    #     ax2.tick_params(axis='y', labelcolor=color2)

    #     fig.tight_layout()
    #     plt.show()
    #     plt.close(fig)
    


    
    
